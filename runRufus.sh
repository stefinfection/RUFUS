#!/bin/bash

echo "You are running the STAGING version of RUFUS: v0.3.0"
RUFUS_MODULE="RUFUS/stage"

# Check for correct version of gcc
gcc_expected="10.2.0"
gcc_actual=$(gcc --version | grep -oP "(?<=gcc \(GCC\) )\d+\.\d+\.\d+")
if [[ "$gcc_expected" != "$gcc_actual" ]]; then
  echo "It looks like you have the wrong version of gcc loaded to run RUFUS: please use the module system to load gcc/10.2.0"
  exit 0
fi

set -e

# This is a rather minimal example Argbash potential
# Example taken from http://argbash.readthedocs.io/en/stable/example.html

# ARG_OPTIONAL_SINGLE([subject],[s],[generator file containing the subject of interest])
# ARG_OPTIONAL_SINGLE([ref],[r],[file path to the desired reference file])
# ARG_OPTIONAL_SINGLE([threads],[t],[number of threads to use])
# ARG_OPTIONAL_SINGLE([kmersize],[k],[size of Khmer to use])
# ARG_OPTIONAL_SINGLE([min],[m],[overwrites the minimum k-mer count to call variant])
# ARG_POSITIONAL_INF([controls],[generator files containing the control subjects],[0])

# ARG_HELP([The general script's help msg])
# ARGBASH_GO()
# needed because of Argbash --> m4_ignore([
### START OF CODE GENERATED BY Argbash v2.5.1 one line above ###
# Argbash is a bash code generator used to get arguments parsing right.
# Argbash is FREE SOFTWARE, see https://argbash.io for more info
# Generated online by https://argbash.io/generate
MaxHashDepth=1200 #need to make this a passed option
RDIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" >/dev/null 2>&1 && pwd)"

die() {
  local _ret=$2
  test -n "$_ret" || _ret=1
  test "$_PRINT_HELP" = yes && print_help >&2
  echo "$1" >&2
  exit ${_ret}
}

begins_with_short_option() {
  local first_option all_short_options
  all_short_options='srtkmh'
  first_option="${1:0:1}"
  test "$all_short_options" = "${all_short_options/$first_option/}" && return 1 || return 0
}

# THE DEFAULTS INITIALIZATION - POSITIONALS
_positionals=()
_arg_exclude=()
# THE DEFAULTS INITIALIZATION - OPTIONALS
_arg_controls=()
_arg_subject=
_arg_ref=
_arg_threads=
_arg_kmersize=
_arg_min=
_arg_refhash=
_arg_saliva="FALSE"
_arg_exome="FALSE"
_MaxAlleleSize="1000"
_arg_mosaic="FALSE"
_assemblySpeed="full"
_parallel_jelly="no"
_pairedEnd="true"
_arg_region=
_arg_filterK=1
_arg_ParLowK=2
_filterMinQ=15
_chunkSize=0
_arg_stop="nope"
print_help() {
  printf "%s\n" "The general script's help msg"
  printf 'Usage: %s [-s|--subject <arg>] [-r|--ref <arg>] [-t|--threads <arg>] [-k|--kmersize <arg>] [-m|--min <arg>] [-h|--help] [<controls-1>] ... [<controls-n>] ...\n' "$0"
  printf "\t%s\n" "-s,--subject: bam/cram/fastq(or pair of fastq files)/generator file containing the subject of interest (no default, only one subject per run for now)"
  printf "\t%s\n" "-c, --controls: bam/cram/fastq(or pair of fastq files)/generator file for the sequence data of the control sample (can be used multipe times)"
  printf "\t%s\n" "-e,--exclude: Jhash file of kmers to exclude from mutation list, k must be  (no default, can be used multiple times)"
  printf "\t%s\n" "-se, --single_end_reads: subject bam file is single end reads, not paired (default is to assume paired end data)"
  printf "\t%s\n" "-r,--ref: file path to the desired reference file (no default)"
  printf "\t%s\n" "-cr,--cramref: file path to the desired reference file to decompress input cram files (no default)"
  printf "\t%s\n" "-t,--threads: number of threads to use (no default) (min 3)"
  printf "\t%s\n" "-k,--kersize: size of k-mer to use (no default)"
  printf "\t%s\n" "-m,--min: overwrites the minimum k-mer count to call variant (no default)"
  printf "\t%s\n" "-i, --saliva: flag to indicate that the subject sample is a buccal swab and likely contains a significant fraction of contaminant DNA"
  printf "\t%s\n" "-mx, --MaxAllele: Max size for insert/deletion events to put the entire alt sequence in. (default 1000)"
  printf "\t%s\n" "-L, --Report_Low_Freq: Reprot Mosaic/Low Frequency/Somatic variants (default FALSE)"
  printf "\t%s\n" "-cs, --chunk-size: Runs RUFUS individually on chunks of the genome according to the provided argument (minimum 1000bp)"
  printf "\t%s\n" "-CLEAN: Does not do a rufus run but cleans up intermediate files created by RUFUS"
  printf "\t%s\n" "-h,--help: HELP!!!!!!!!!!!!!!!"
  printf "\t%s\n" "-d: Dev Help, more options that can be confusing"
}

print_devhelp() {
  printf "%s\n" "The general script's help msg"
  printf 'Usage: %s [-s|--subject <arg>] [-r|--ref <arg>] [-t|--threads <arg>] [-k|--kmersize <arg>] [-m|--min <arg>] [-h|--help] [<controls-1>] ... [<control\
s-n>] ...\n' "$0"
  printf "\t%s\n" "-s,--subject: bam/cram/fastq(or pair of fastq files)/generator file containing the subject of interest (no default, only one subject per run for now)"
  printf "\t%s\n" "-c, --controls: bam/cram/fastq(or pair of fastq files)/generator file for the sequence data of the control sample (can be used multiple times)"
  printf "\t%s\n" "-e,--exclude: Jhash file of kmers to exclude from mutation list, k must be  (no default, can be used multiple times)"
  printf "\t%s\n" "-se, --single_end_reads: subject bam file is single end reads, not paired (default is to assume paired end data)"
  printf "\t%s\n" "-r,--ref: file path to the desired reference file (no default)"
  printf "\t%s\n" "-cr,--cramref: file path to the desired reference file to decompress input cram files (no default)"
  printf "\t%s\n" "-t,--threads: number of threads to use (no default) (min 3)"
  printf "\t%s\n" "-k,--kmersize: size of k-mer to use (no default)"
  printf "\t%s\n" "-m,--min: overwrites the minimum k-mer count to call variant (no default)"
  printf "\t%s\n" "-i, --saliva: flag to indicate that the subject sample is a buccal swab and likely contains a significant fraction of contaminant DNA"
  printf "\t%s\n" "-mx, --MaxAllele: Max size for insert/deletion events to put the entire alt sequence in. (default 1000)"
  printf "\t%s\n" "-L, --Report_Low_Freq: Report Mosaic/Low Frequency/Somatic variants (default FALSE)"
  printf "\t%s\n" "-CLEAN: Does not do a rufus run but cleans up intermediate files created by RUFUS"

  printf "\t%s\n" "################################################################################################"
  printf "\t%s\n" "Extra options, mosstly experimental or algorithm parameters that you normaly dont need to adjust"
  printf "\t%s\n" "################################################################################################"

  printf "\t%s\n" "-f,--refhash: Jhash file containing reference hashList (no default)"
  printf "\t%s\n" "-mx, --MaxAllele: Max size for insert/deletion events to put the entire alt sequence in. (default 1000)"
  printf "\t%s\n" "-ex, --exome: flag to set if your input data is exome sequencing.  Distribution model is not used, -m = 20, saliva fix is set, max kmer depth set to 1 million (EXPERIMENTAL values used here have not been exhaustivly tested)"
  printf "\t%s\n" "-q1,--fastq1: If starting from fastq files, a list of the mate1 fastq files to improve RUFUS.filter"
  printf "\t%s\n" "-q2,--fastq2: If starting from fastq files, a list of the mate2 fastq files to improve RUFUS.filter"
  printf "\t%s\n" "-vs, --Very_Short_Assembly: use very short assembly methods, recommended when you are expecting over 10,000 variants "
  printf "\t%s\n" "-pj, --Parallelize_Jelly: parallelize jellyfish step, only use if you have more than 96G of ram"
  printf "\t%s\n" "-R, --Region: Run RUFUS only on a samtools style region"
  printf "\t%s\n" "-fk, --filterK: kmer threshold for number of kmers required to keep a read during filtering (default = 1)"
  printf "\t%s\n" "-fq, --filterMinQ: Minimum base quality for filter step, any kmer with any bases lower than this quality will be ignored (default = 15)"
  printf "\t%s\n" "-pl, --ParLowK: Lowest kmer count to be kept when counting parent jellyfish tables (default = 2, using 1 will SIGNIFICANTLY increase run time and is not advised)"
  printf "\t%s\n" "-StJ: Stop run after jellyfish steps"    #TODO: dont require reference and other non needed options if this is set
  printf "\t%s\n" "-StH: Stop run after hash compare steps" #TODO: dont require reference and other non needed options if this is set
  printf "\t%s\n" "-StF: Stop run after filter steps"
  printf "\t\t%s\n" "This can be useful when you know you have low level contamination and want to remove kmers up to a certain count"
  printf "\t%s\n" "-h,--help: HELP!!!!!!!!!!!!!!!"
  printf "\t%s\n" "-d,--devhelp: HELP!!! for developers"

}
re='^[0-9]+$'
parse_commandline() {
  while test $# -gt 0; do
    _key="$1"
    case "$_key" in
    -s | --subject)
      test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
      FileName=$(basename "$2")
      Extension="${FileName##*.}"
      genName=$FileName
      if [[ $Extension == 'fastq' ]] || [[ $Extension == 'fq' ]] || [[ $Extension == 'gz' ]]; then
        echo "" >"$FileName".generator
        _arg_subject=("$FileName".generator)
      fi
      while [[ $2 != -* ]]; do
        FileName=$(basename "$2")
        Extension="${FileName##*.}"
        echo "ext4nsion = $Extension"
        if [ $Extension = "fastq" ] || [ $Extension = "fq" ] || [ $Extension = "gz" ]; then
          echo "cool we found a fastq"
          if [[ $Extension == 'gz' ]]; then
            echo "perl $RDIR/scripts/FastqToSam.pl <(zcat $2)" >>"$genName".generator
          else
            echo "perl $RDIR/scripts/FastqToSam.pl <(cat $2)" >>"$genName".generator
          fi
        else
          echo "even cooler, fond one thats not a fastq"
          _arg_subject=("$2")
        fi
        shift
      done
      ;;
    -r | --ref)
      test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
      _arg_ref="$2"
      shift
      ;;

    -cr | --cramref)
      test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
      _arg_cramref="$2"
      shift
      ;;

    -q1 | --fastq1)
      test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
      _arg_fastqA="$2"
      shift
      ;;
    -q2 | --fastq2)
      test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
      _arg_fastqB="$2"
      shift
      ;;
    -t | --threads)
      test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
      _arg_threads="$2"
      if ! [[ $_arg_threads =~ $re ]]; then
        echo "Threads must be a number "
        exit 100
      fi
      shift
      ;;

    -f | --refhash)
      test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
      _arg_refhash="$2"
      shift
      ;;
    -k | --kmersize)
      test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
      _arg_kmersize="$2"
      shift
      ;;
    -c | --controls)
      test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
      echo "checking parent count $#"
      FileName=$(basename "$2")
      Extension="${FileName##*.}"
      genName=$FileName
      if [[ $Extension == 'fastq' ]] || [[ $Extension == 'fq' ]] || [[ $Extension == 'gz' ]]; then
        echo "" >"$FileName".generator
        _arg_controls+=("$FileName".generator)
      fi
      while [[ $2 != -* ]]; do
        FileName=$(basename "$2")
        Extension="${FileName##*.}"
        echo "refext4nsion = $Extension"
        if [ $Extension = "fastq" ] || [ $Extension = "fq" ] || [ $Extension = "gz" ]; then
          echo "cool we found a fastq"
          if [[ $Extension == 'gz' ]]; then
            echo "perl $RDIR/scripts/FastqToSam.pl <(zcat $2)" >>"$genName".generator
          else
            echo "perl $RDIR/scripts/FastqToSam.pl <(cat $2)" >>"$genName".generator
          fi
        else
          echo "even cooler, fond one thats not a fastq"
          _arg_controls+=("$2")
        fi
        shift
      done
      ;;
    -e | --exclude)
      test $# -lt 2 && die "Missing value for the optional argument '$key'." 1
      _arg_exclude+=("$2")
      shift
      ;;
    -m | --min)
      test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
      _arg_min="$2"
      if ! [[ $_arg_min =~ $re ]]; then
        echo "arg -m must be a number "
        exit 100
      fi
      shift
      ;;
    -fk | --filterK)
      test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
      _arg_filterK=$2
      if ! [[ $_arg_filterK =~ $re ]]; then
        echo "arg -fk or --filterK must be a number "
        exit 100
      fi
      shift
      ;;
    -fq | --filterMinQ)
      test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
      _filterMinQ=$2
      if ! [[ $_filterMinQ =~ $re ]]; then
        echo "arg -fq or --filterMinQ must be a number "
        exit 100
      fi
      shift
      ;;
    -pl | --ParLowK)
      test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
      _arg_ParLowK=$2
      if ! [[ $_arg_ParLowK =~ $re ]]; then
        echo "arg -pl or --ParLowK must be a number "
        exit 100
      fi
      shift
      ;;
    -cs | --chunkSize)
      test $# -lt 1 && die "Must provide a chunk size of at least 1; units in MB '$_key'." 1
      _chunkSize=$2
      if ! [[ $_chunkSize =~ $re ]]; then
        echo "arg -cs or --chunkSize must be a number of at least 1 without units"
        exit 100
      fi
      shift
      ;;
    -R | --region)
      test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
      _arg_region="$2"
      if [[ -z $_arg_region ]]; then
        echo "arg region must not be empyt "
        exit 100
      fi
      shift
      ;;
    -i | --saliva)
      _arg_saliva="TRUE"
      echo "INFO: Saliva subject sample provided"
      ;;
    -vs | --Very_Short_Assembly | --vs)
      _assemblySpeed="veryfast"
      echo "INFO: Very fast assembly being used"
      ;;
    -se | --single_end_reads | --se)
      _pairedEnd="false"
      echo "INFO: Sample Bam file is single end data"
      ;;
    -pj | --Parallelize_Jelly | --pj)
      _parallel_jelly="yes"
      echo "INFO: Paralellizing jellyfish, assuming 3 samples"
      ;;
    -ex | --exome)
      _arg_exome="TRUE"
      echo "INFO: Exome run"
      ;;
    -A | --MaxAllele)
      test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
      _MaxAlleleSize="$2"
      if ! [[ $_MaxAlleleSize =~ $re ]]; then
        echo "MaxAlleleSize must be a number "
        exit 100
      fi
      echo "INFO: MaxAlleleSize set to $_MaxAlleleSize"
      shift
      ;;
    -L | --Report_Low_Freq)
      _arg_mosaic="TRUE"
      echo "INFO: Reporting mosaic/low frequence variants"
      ;;
    -h | --help)
      print_help
      exit 0
      ;;
    -h*)
      print_help
      exit 0
      ;;
    -d | --devhelp)
      print_devhelp
      exit 0
      ;;
    -StJ)
      _arg_stop="jelly"
      echo "Stopping run after jellyfish steps"
      ;;
    -StH)
      _arg_stop="hash"
      echo "Stopping run after Hash compare steps"
      ;;

    -StF)
      _arg_stop="filter"
      echo "Stopping run after filter steps"
      ;;
    -CLEAN)
      echo "cleaning up intermeidate files"
      rm *generator.Jhash *generator.Jhash.histo *generator.Jhash.histo.7.7.dist *generator.Jhash.histo.7.7.out *generator.Jhash.histo.7.7.prob *generator.k25_c4.HashList *generator.Mutations.Mate1.fastq *generator.Mutations.Mate2.fastq *.generator.temp *.generator.temp.mate1.fastq *.temp.mate2.fastq *.generator.V2.overlap.fastq *.generator.V2.overlap.fastqd *.generator.V2.overlap.hashcount.fastq *.generator.V2.overlap.hashcount.fastq.bam.vcf *.generator.V2.overlap.hashcount.fastq.bam.vcf.bed
      echo "cleanup done"
      exit 1
      ;;
    *)
      echo "ERROR: Unkown argument $1"
      exit 100
      _positionals+=("$1")
      ;;

    esac
    shift
  done
}

assign_positional_args() {
  _positional_names=()
  _our_args=$((${#_positionals[@]} - ${#_positional_names[@]}))
  for ((ii = 0; ii < _our_args; ii++)); do
    _positional_names+=("_arg_exclude[$((ii + 0))]")
  done

  for ((ii = 0; ii < ${#_positionals[@]}; ii++)); do
    eval "${_positional_names[ii]}=\${_positionals[ii]}" || die "Error during argument parsing, possibly an Argbash bug." 1
  done
}

which samtools || die "ERROR, samtools not installed, exiting"
#which bamtools || die "ERROR, bamtools not installed, exiting"

parse_commandline "$@"

# [ <-- needed because of Argbash

##############################__Print out all parameters__#################################################
echo "~~~~~~~~~~~~ printing out paramater values used in script ~~~~~~~~~~~~~~~~"
echo "  _arg_exclude=:"
for each in "${_arg_exclude[@]}"; do
  echo "		$each"
done
echo "  _arg_controls=:"
arg_control_string=""
for each in "${_arg_controls[@]}"; do #
  #
  echo "		$each"
  arg_control_string="$arg_control_string $each" #
done

echo "  _arg_subject=$_arg_subject"
echo "  _arg_ref=$_arg_ref"
echo "  _arg_threads=$_arg_threads"
echo "  _arg_kmersize=$_arg_kmersize"
echo "  _arg_min=$_arg_min"
echo "  _arg_refhash=$_arg_refhash"
echo "  _arg_saliva=$_arg_saliva"
echo "  _arg_exome=$_arg_exome"
echo "  _MaxAlleleSize=$_MaxAlleleSize"
echo "  _arg_mosaic=$_arg_mosaic"
echo "  _assemblySpeed=$_assemblySpeed"
echo "  _parallel_jelly=$_parallel_jelly"
echo "  _pairedEnd=$_pairedEnd"
echo "  _arg_region=$_arg_region"
echo "  _arg_filterK=$_arg_filterK"
echo "  _arg_ParLowK=$_arg_ParLowK"
echo "  _chunkSize=$_chunkSize"
echo "  _filterMinQ=$_filterMinQ"

##############################__CHECK_FOR_MANDATORY_PARAMS__#################################################
if [ -z $_arg_kmersize ]; then
  echo "INFO: You did not profide a kmer size, running with the default 25"
  _arg_kmersize="25"
  #echo "You must provide a kmer size [--kmersize|-k] (we recommend a kmer size of 25)"
  #echo "Killing run with non-zero exit status"
  #kill -9 $$
fi

if [ -z $_arg_threads ]; then
  echo "INFO: no thread argument given, running with all avaialble threads = $(nproc)"
  _arg_threads=$(nproc)
fi

if [ -z $_arg_subject ]; then
  echo "ERROR: you must provide a subject sample (sample you want to call variants in)"
  kill -9 $$
fi

if [ ${#_arg_exclude[@]} -eq "0" ] && [ ${#_arg_controls[@]} -eq "0" ]; then
  echo "You must provide RUFUS with atleast one control or exclude sample"
  echo "Killing run with non-zero exit status"
  kill -9 $$
fi

#########__remove -e and --exclude from _arg_exclude array__################
new_array=()
for value in "${_arg_exclude[@]}"; do
  [[ $value != --exclude ]] && new_array+=($value)
done
ExcludeTemp=("${new_array[@]}")
unset new_array

new_array=()
for value in "${ExcludeTemp[@]}"; do
  [[ $value != -e ]] && new_array+=($value)
done
_arg_exclude=("${new_array[@]}")
unset new_arary
unset ExcludeTemp
########################Setting up Exome Run EXPERIMENTAL ##################################

if [ $_arg_exome == "TRUE" ]; then
  echo "Exome run set.  Setting max kmer to 1M and saliva = true and making sure a lower cutoff was set "
  MaxHashDepth=100000000
  _arg_saliva="TRUE"

  if [ -z $_arg_min ]; then
    echo "Minimum not provided, picking a min of 20 for the alt count"
    _arg_min="20"
  fi
fi

#############################################################################################################

###############__PRINTING_OUT_ARG_BASH_VALUES__##############
#echo "Value of --subject: $_arg_subject"                    #
#echo "Value of --controls:"                                 #
#for each in "${_arg_controls[@]}"                           #
#do                                                          #
#  echo "$each"                                              #
#done                                                        #
#echo "Value of --threads: $_arg_threads"                    #
#echo "Value of --kmersize: $_arg_kmersize"                  #
#echo "Value of --ref: $_arg_ref"                            #
#echo "Value of --minCount $_arg_min"                        #
#############################################################

Parents=("${_arg_controls[@]}")
_arg_ref_cat="${_arg_ref%.*}"

###############__CHECK_IF_ALL_REFERENCE_FILES_EXIST__#####################
if [[ ! -e "$_arg_ref".sa ]] && [[ ! -e "$_arg_ref_cat".sa ]]; then
  echo "Reference file not built for BWA"
  echo "this program requires the existence of the file" "$_arg_ref".sa
  echo "Killing run with non-zero status"
  kill -9 $$
fi

if [[ ! -e "$_arg_ref".bwt ]] && [[ ! -e "$_arg_ref_cat".bwt ]]; then
  echo "Reference file not built for BWA"
  echo "this program requires the existence of the file" "$_arg_ref".bwt
  echo "Killing run with non-zero status"
  kill -9 $$
fi

if [[ ! -e "$_arg_ref".pac ]] && [[ ! -e "$_arg_ref_cat".pac ]]; then
  echo "Reference file not built for BWA"
  echo "this program requires the existence of the file" "$_arg_ref".pac
  echo "Killing run with njon-zero status"
  kill -9 $$
fi

if [[ ! -e "$_arg_ref".amb ]] && [[ ! -e "$_arg_ref_cat".amb ]]; then
  echo "Reference file not built for BWA"
  echo "this program requires the existence of the file" "$_arg_ref".amb
  echo "Killing run with non-zero status"
  kill -9 $$
fi

if [[ ! -e "$_arg_ref".ann ]] && [[ ! -e "$_arg_ref_cat".ann ]]; then
  echo "Reference file not built for BWA"
  echo "this program requires the existence of the file" "$_arg_ref".ann
  echo "Killing run with non-zero status"
  kill -9 $$
fi

###### when we add PB need to check its reference stuff here
###########################################################################

refFileName=$(basename "$parent")
refExtension="${refFileName##*.}"

if [[ "$refExtension" != fa ]] && [[ -e "$_arg_ref".fa ]]; then
  _arg_ref="$_arg_ref".fa
elif [[ "$refExtension" != fasta ]] && [[ -e "$_arg_ref".fasta ]]; then
  _arg_ref="$_arg_ref".fasta
fi

if [[ ! -e "$_arg_ref" ]]; then
  echo "cannot find reference file " "$_arg_ref"
  echo "tried extensions: "
  echo "no extension "
  echo ".fa"
  echo ".fasta"
  echo "killing run with non-zero exit status"
  kill -9 $$
fi
if [[ -e "$_arg_ref_cat".sa ]]; then
  _arg_ref_bwa=$_arg_ref_cat
else
  _arg_ref_bwa=$_arg_ref
fi

echo "@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@"
echo "Final reference path being used is" "$_arg_ref"
echo "Final bwa reference path being used is" "$_arg_ref_bwa"
echo "@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@"

##########################__SET_EXECUTABLE_PATHS__##############################
# todo: make $RDIR optional argument for running on chpc
RemoveCoInheritedVars=$RDIR/scripts/remove_coinherited.sh
RunChunk=$RDIR/scripts/RunChunk.sh
############################################################################################

#todo: put loop around entire thing for parallelization
#todo: compartmentalize all of this?

#TODO: need to set this to argument
CHUNK_SIZE=1000000

# TODO: this is hardcoded for GRCh38 - need to be able to take in reference and extract these values
CHRS=(
  "1"
  "2"
  "3"
  "4"
  "5"
  "6"
  "7"
  "8"
  "9"
  "10"
  "11"
  "12"
  "13"
  "14"
  "15"
  "16"
  "17"
  "18"
  "19"
  "20"
  "21"
  "22"
  "X"
  "Y"
)

# GRCh38
CHR_LENGTHS=(
  248956422
  242193529
  198295559
  190214555
  181538259
  170805979
  159345973
  145138636
  138394717
  133797422
  135086622
  133275309
  114364328
  107043718
  101991189
  90338345
  83257441
  80373285
  58617616
  64444167
  46709983
  50818468
  156040895
  57227415
)

SLURM_SCRIPT="#!/bin/bash
#SBATCH --time=2-00:00:00
#SBATCH --nodes=1
#SBATCH --account=marth-rw
#SBATCH --partition=marth-rw
#SBATCH -o ${OUT_SLURM_DIR}%j/out.out
#SBATCH -e ${OUT_SLURM_DIR}%j/error.err
module load samtools/1.16
module load bamtools/2.5.1
module load bedtools/2.28.0
module load htslib/1.16
module load gcc/10.2.0
module load $RUFUS_MODULE"

# todo: check to see if this is correct
UNID=$USER

n=${#CHRS[@]}
for ((i = 0; i < n; i++)); do
  curr_len="${CHR_LENGTHS[i]}"
  curr_chr="${CHRS[i]}"
  ((chunks = curr_len / CHUNK_SIZE + 1))
  echo "number of chunks is $chunks"

  start_coord=1
  echo "Starting loop for index $i chr${curr_chr}"
  for ((c = 1; c <= chunks; c++)); do
    # TODO: how can I do this in the container?? - look at multi-execution we used on AWS before
    curr_jobs=($(squeue -u $UNID | wc -l))
    while [ $curr_jobs -gt 1000 ]; do
      sleep 60
      curr_jobs=($(squeue -u $UNID | wc -l))
    done

    ((end_coord = start_coord + CHUNK_SIZE - 1))
    if [ $end_coord -gt $curr_len ]; then
      echo "passed end coordinate, setting to $curr_len"
      end_coord=$curr_len
    fi

    # Make region dir
    TARGET_DIR="chr${curr_chr}/chr${curr_chr}_${start_coord}_${end_coord}/"
    mkdir -p $TARGET_DIR

    # Compose slurm script
    SLURM_FILE="${TARGET_DIR}rufus_HCC.sh"
    echo -e "$SLURM_SCRIPT" >$SLURM_FILE
    echo -e "cd ${OUT_DIR}${TARGET_DIR} \n" >>$SLURM_FILE
    echo -e "bash \$RUFUS_ROOT/runRufus.sh -s $SUBJECT -c $CONTROL -r $REFERENCE -f ${RESOURCE_DIR}GRCh38_full_analysis_set_plus_decoy_hla.25.Jhash -m 5 -k 25 -t 40 -L -vs -R chr${curr_chr}:${start_coord}-${end_coord}" >>$SLURM_FILE

    # Get run going
    #todo: going to have to figure out how to get job ID back from sbatch and store in array
    sbatch $SLURM_FILE

    # Advance start coordinate
    ((start_coord = end_coord + 1))
  done
  echo "Done with chr${curr_chr}"
done

#todo: how to force wait here until slurm job completed?
#todo: LEFT OFF HERE - put removal into its own slurm job and insert a dependency array for all jobs -d after:first_job:last_job

echo "about to head prefinal vcf prior to zipping"
bcftools view -h "./$PREFINAL_VCF" | head -n 5

bgzip -f "./$PREFINAL_VCF"
tabix "./${PREFINAL_VCF}.gz"

echo "Removing inherited variant calls that co-occur on the same reads as a somatic..."
bash $RemoveCoInheritedVars $_arg_ref "./${PREFINAL_VCF}.gz" $ProbandGenerator $arg_control_string

echo "done with everything"
exit 0
# ] <-- needed because of Argbash
